<program> ::= <statement_list>

<statement_list> ::= <statement> <statement_list> | EOF

<statement> ::= <expression>
<statement> ::= <func_def>
<statement> ::= <var_def>
<statement> ::= <func_call>
<statement> ::= if <expression> { <statement_list> } else { <statement_list> }
<statement> ::= while <expression> { <statement_list> }


// Příkaz může být použit v těle libovolné funkce, ale ne v hlavním těle programu.
<return> ::= return <expression> | ε

<func_def> ::= <func_header> <func_body>

<func_header> ::= func <ID> ( <parameters_list> ) <func_header_ret>

<func_header_ret> ::= -> <return_type> | ε

<parameters_list> ::= <parameter> <parameters_list_more> | ε

<parameters_list_more> ::= , <parameter> <parameters_list_more> | ε

<parameter> ::= _ <ID> : <type> | <ID> _ : <type>

<func_body> ::= { <statement_list> <return> }

// Je-li možné při překladu odvodit typ výrazu přiřazovaného do
// proměnné, tak je možné část ’: typ’ vypustit a typ proměnné id odvodit.
// Pokud je typ proměnné zadán, lze část ’= výraz’ vynechat.

<var_def> ::= let <ID> <var_def_statement>
<var_def> ::= var <ID> <var_def_statement>

<var_def_statement> ::= : <var_type_fork> <var_def_statement_expr>
<var_def_statement> ::= = <expression>

<var_def_statement_expr> ::= = <expression>
<var_def_statement_expr> ::= ε

<var_type_fork> ::= <type>
<var_type_fork> ::= <nil>

<func_call> ::= <ID> ( <call_parameters_list> )

<call_parameters_list> ::= <call_parameter> <call_parameters_list_more> | ε

<call_parameters_list_more> ::= , <call_parameter> <call_parameters_list_more> | ε

<call_parameter> ::= _ <ID> : <type> | <ID> | <const>

<ID> = id

<return_type> ::= <type>

<type> ::= Int | Double | Bool | String

<nil> ::= nil

// type_* je typ tokenu pro konstanty
<const> ::= type_int | type_double | type_string

* expression processing in precedence analysis
<expression> ::= prec_expr
<expression> ::= <func_call>
